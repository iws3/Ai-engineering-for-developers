/**\n * CHAPTER 1.2: HOW TYPESCRIPT COMPILES\n * ğŸ”§ Understanding the TypeScript Compilation Pipeline\n * \n * ğŸ“š What You'll Learn:\n * TypeScript is not magic - it's a COMPILER that:\n * 1. Reads your .ts files\n * 2. Checks types against rules\n * 3. Produces .js files (without types)\n * 4. That's it! Everything else is tooling.\n */\n\n// ========== THE JOURNEY: FROM .TS TO .JS ==========\n\n/**\n * Input file: myapp.ts (with TypeScript types)\n * \n * const numbers: number[] = [1, 2, 3];\n * numbers.push(\"four\"); // âŒ COMPILE ERROR (string, not number)\n * \n * â†“â†“â†“ TypeScript Compiler Processes â†“â†“â†“\n * \n * Output file: myapp.js (NO TYPES, pure JavaScript)\n * \n * const numbers = [1, 2, 3];\n * // The type annotation \"number[]\" is DELETED\n * \n * Most important fact:\n * TypeScript is COMPLETELY ERASED during compilation.\n * The generated JavaScript doesn't know about types at all.\n * That's why ALL type checking happens BEFORE you run code.\n */\n\n\n// ========== STEP 1: LEXICAL ANALYSIS ==========\n\n/**\n * TypeScript compiler reads your source code and breaks it into TOKENS.\n * \n * Source code:\n * const message: string = \"Hello\";\n * \n * Becomes tokens:\n * CONST | IDENTIFIER(message) | COLON | STRING | EQUALS | STRING(\"Hello\") | SEMICOLON\n * \n * The compiler now understands the structure.\n */\n\n\n// ========== STEP 2: PARSING INTO AST ==========\n\n/**\n * AST = Abstract Syntax Tree\n * This is how the compiler represents your code internally.\n * \n * Example code:\n * function add(a: number, b: number): number {\n *   return a + b;\n * }\n * \n * Becomes (simplified) AST:\n * FunctionDeclaration {\n *   name: \"add\"\n *   parameters: [\n *     { name: \"a\", type: \"number\" },\n *     { name: \"b\", type: \"number\" }\n *   ]\n *   returnType: \"number\"\n *   body: [\n *     ReturnStatement {\n *       value: BinaryExpression { left: \"a\", operator: \"+\", right: \"b\" }\n *     }\n *   ]\n * }\n * \n * Now the compiler understands what your code MEANS, not just its syntax.\n */\n\n\n// ========== STEP 3: TYPE CHECKING ==========\n\n/**\n * This is where the MAGIC happens.\n * The compiler walks through the AST and checks:\n * - Is this variable used correctly?\n * - Are these types compatible?\n * - Does this function call match the definition?\n * \n * Example:\n * function add(a: number, b: number): number {\n *   return a + b;\n * }\n * \n * add(5, 3); // âœ… PASS: 5 is number, 3 is number, returns number\n * add(5, \"3\"); // âŒ FAIL: \"3\" is string, not number\n * const result: string = add(5, 3); // âŒ FAIL: add returns number, not string\n * \n * If ANY check fails â†’ COMPILE ERROR\n * The compiler STOPS and tells you exactly what's wrong.\n */\n\n\n// ========== STEP 4: CODE GENERATION ==========\n\n/**\n * If type checking passed, TypeScript generates JavaScript.\n * \n * TypeScript source:\n * const x: number = 5;\n * const y: number = 10;\n * const z: number = x + y;\n * \n * Generated JavaScript (notice: no types!):\n * const x = 5;\n * const y = 10;\n * const z = x + y;\n * \n * Every type annotation is deleted.\n * Every type statement is deleted.\n * Only the LOGIC remains.\n * \n * This is CRITICAL: TypeScript types are ZERO COST ABSTRACTION.\n * They only exist during development. In production:\n * - TypeScript files don't exist\n * - No runtime overhead\n * - No type checking in JavaScript\n * - Just plain JavaScript running\n */\n\n\n// ========== THE COMPILATION PIPELINE: VISUAL ==========\n\n/*\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Source Code (.ts file)                                      â”‚\nâ”‚ const x: number = \"hello\";  â† Type annotation              â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                   â”‚ LEXICAL ANALYSIS\n                   â†“ (Break into tokens)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Token Stream                                                â”‚\nâ”‚ CONST | IDENTIFIER | COLON | TYPE | ...                   â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                   â”‚ PARSING\n                   â†“ (Build AST)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Abstract Syntax Tree (AST)                                  â”‚\nâ”‚ VariableDeclaration { name: \"x\", type: \"number\", ... }    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                   â”‚ TYPE CHECKING\n                   â†“ (Verify types)\n        âŒ ERROR: string is not assignable to number\n        TYPE CHECK FAILED - COMPILATION STOPS HERE\n        âœ… User sees error\n        âŒ No JavaScript file created\n                   â†“ (if types were correct)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Generated JavaScript (.js file)                             â”‚\nâ”‚ const x = \"hello\";  â† Type annotation DELETED               â”‚\nâ”‚                        (no type safety in production!)       â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n*/\n\n\n// ========== REAL EXAMPLE: STEP BY STEP ==========\n\n// BEFORE COMPILATION:\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nfunction saveUser(user: User): Promise<User> {\n  // TypeScript checks:\n  // âœ… user has fields: id (number), name (string), email (string)\n  // âœ… Returns Promise<User>\n  \n  return fetch('/api/users', {\n    method: 'POST',\n    body: JSON.stringify(user),\n  }).then(res => res.json());\n}\n\nconst newUser: User = {\n  id: 1,\n  name: 'Alice',\n  email: 'alice@example.com',\n};\n\nsaveUser(newUser); // âœ… Types correct\n\n// AFTER COMPILATION (JavaScript output):\n\n/*\nfunction saveUser(user) {\n  return fetch('/api/users', {\n    method: 'POST',\n    body: JSON.stringify(user),\n  }).then(res => res.json());\n}\n\nconst newUser = {\n  id: 1,\n  name: 'Alice',\n  email: 'alice@example.com',\n};\n\nsaveUser(newUser);\n\nNotice:\n- âœ… All code logic is preserved\n- âŒ interface User declaration is GONE\n- âŒ Type annotations (: User, : Promise<User>) are GONE\n- The JavaScript doesn't know about types anymore!\nBut that's fine because:\n- Types were safe at compile time\n- JavaScript was already verified\n- No type safety is NEEDED in production\n*/\n\n\n// ========== WHY THIS APPROACH?\n why (not runtime type checking) ==========\n\n/**\n * Option 1: Keep types in JavaScript (what TypeScript does NOT do)\n * \n * Pros: Runtime type safety\n * Cons:\n * - Larger file size\n * - Slower runtime (checking types on every call)\n * - Complexity in production\n * - Types add overhead\n * \n * Option 2: Erase types after compilation (what TypeScript DOES)\n * \n * Pros:\n * - Zero runtime overhead\n * - Smaller file sizes\n * - Better performance\n * - Type safety where it matters (dev time)\n * \n * Result: TypeScript chose Option 2\n * Philosophy: \"Fail early, run fast\"\n * Catch bugs at compile time â†’ run production without checking\n */\n\n\n// ========== THE TSCONFIG.JSON: YOUR COMPILATION RULES ==========\n\n/**\n * TypeScript behavior is controlled by tsconfig.json:\n * \n * {\n *   \"compilerOptions\": {\n *     \"target\": \"ES2020\",              // What version of JS to output\n *     \"module\": \"ESNext\",              // Module system (CommonJS, ES Modules, etc)\n *     \"strict\": true,                  // Enable all strict type checks\n *     \"esModuleInterop\": true,         // Easier module interoperability\n *     \"skipLibCheck\": true,            // Skip type checking of .d.ts files\n *     \"forceConsistentCasingInFileNames\": true,\n *     \"resolveJsonModule\": true,       // Import JSON files\n *     \"declaration\": true,             // Generate .d.ts files (for libraries)\n *     \"outDir\": \"./dist\",              // Where to put compiled JS\n *     \"rootDir\": \"./src\",              // Where to find .ts files\n *   },\n *   \"include\": [\"src\"],\n *   \"exclude\": [\"node_modules\", \"dist\"]\n * }\n * \n * These options control:\n * - HOW strict the type checking is\n * - WHICH JavaScript features to produce\n * - OUTPUT location and format\n */\n\n\n// ========== STRICT MODE: THE MOST IMPORTANT SETTING ==========\n\n/**\n * In tsconfig.json, \"strict\": true enables all strict checks:\n * \n * 1. strictNullChecks\n *    Without: null can be assigned to any type\n *    With: null must be explicit\n *    \n *    const x: string = null; // âŒ ERROR (strict), âœ… OK (non-strict)\n * \n * 2. strictFunctionTypes\n *    Without: Functions types are loosely compatible\n *    With: Function types must match exactly\n * \n * 3. strictBindCallApply\n *    Without: bind/call/apply accept any arguments\n *    With: Must match function signature\n * \n * 4. strictPropertyInitialization\n *    Without: Class properties can be undefined\n *    With: Must be initialized\n * \n * RECOMMENDATION: ALWAYS use \"strict\": true\n * It prevents entire classes of bugs.\n */\n\n\n// ========== THE COMPILATION PROCESS IN PRACTICE ==========\n\n/*\nWhen you run: tsc (TypeScript Compiler)\n\n1. tsc reads tsconfig.json\n2. tsc finds all .ts files\n3. For EACH .ts file:\n   a. Lexical analysis\n   b. Parsing (AST creation)\n   c. Type checking\n   d. If types OK â†’ Generate .js\n      If types FAIL â†’ Print errors, skip .js generation\n4. Output .js files to outDir\n\nIf even ONE file has type errors:\n- âŒ tsc exits with error code\n- âŒ No .js files are generated (or partially generated)\n- âœ… You see error messages explaining problems\n- âœ… You fix them\n- âœ… Run tsc again\n- âœ… This time it succeeds\n*/\n\n\n// ========== INCREMENTAL COMPILATION ==========\n\n/**\n * For large projects, recompiling everything is slow.\n * Solution: Incremental compilation\n * \n * \"incremental\": true in tsconfig.json tells tsc:\n * \"Only recompile files that changed\"\n * \n * How it works:\n * 1. First compilation: compiles everything (slow)\n * 2. Creates .tsbuildinfo file with dependency graph\n * 3. Second compilation: only recompiles changed file and dependents\n * 4. Results: 10x-100x faster for large projects\n * \n * This is crucial for developer experience:\n * - Large project: 30 second full compilation\n * - With incremental: 0.3 second recompilation\n * - Difference: staying focused vs getting distracted\n */\n\n\nexport {};\n