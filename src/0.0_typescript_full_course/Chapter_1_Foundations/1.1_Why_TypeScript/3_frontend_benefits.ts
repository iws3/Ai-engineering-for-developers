/**\n * FRONTEND DEVELOPMENT BENEFITS: DEEP DIVE\n * \n * üìö Understanding why TypeScript transformed modern frontend development\n */\n\n// ========== PROBLEM: FRONTEND COMPLEXITY WITHOUT TYPES ==========\n\n/**\n * React and modern frontend frameworks are component-based:\n * - Components pass props down\n * - Components pass callbacks up\n * - State flows in multiple directions\n * - One prop type error ‚Üí cascades through entire tree\n * \n * Without types, developers must:\n * ‚ùå Remember what props each component needs\n * ‚ùå Pass them in correct order\n * ‚ùå Remember what type each prop should be\n * ‚ùå Hope nothing changed since last use\n * ‚ùå Guess return types of callbacks\n */\n\n\n// ========== USE CASE 1: COMPONENT PROPS TYPE SAFETY ==========\n\ninterface ButtonProps {\n  label: string;\n  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void;\n  variant?: 'primary' | 'secondary' | 'danger';\n  disabled?: boolean;\n  loading?: boolean;\n}\n\nfunction Button(props: ButtonProps): JSX.Element {\n  const { label, onClick, variant = 'primary', disabled = false, loading = false } = props;\n  \n  return (\n    <button\n      onClick={onClick}\n      className={`btn btn-${variant}`}\n      disabled={disabled || loading}\n    >\n      {loading ? 'Loading...' : label}\n    </button>\n  );\n}\n\n// Without TypeScript, using Button is confusing:\n// <Button label=\"Click me\" onClick={...} variant=\"unknown\" />\n// ‚ùå What are valid variants? Maybe \"invalid\" works?\n// ‚ùå Is loading a boolean? String?\n\n// With TypeScript, using Button is clear:\n// <Button\n//   label=\"Click me\"\n//   onClick={(e) => console.log(e)}\n//   variant=\"primary\" // ‚úÖ IDE shows valid options\n//   loading={false} // ‚úÖ IDE knows it must be boolean\n// />\n\n\n// ========== USE CASE 2: FORM STATE MANAGEMENT ==========\n\ninterface FormData {\n  username: string;\n  email: string;\n  age: number;\n  interests: string[];\n  agreeToTerms: boolean;\n}\n\nfunction useFormState(initialState: FormData) {\n  // TypeScript ensures:\n  // ‚úÖ initialState has correct structure\n  // ‚úÖ All fields are present and correct type\n  // ‚úÖ You can't accidentally add wrong fields\n  \n  const [formData, setFormData] = React.useState<FormData>(initialState);\n  \n  const handleChange = (field: keyof FormData, value: any) => {\n    // ‚úÖ field must be one of the actual field names\n    // ‚úÖ TypeScript prevents typos like 'usrname'\n    \n    setFormData(prev => ({\n      ...prev,\n      [field]: value,\n    }));\n  };\n  \n  return { formData, handleChange };\n}\n\n// This prevents classic bugs:\n// handleChange('usrname', 'john'); // ‚ùå COMPILE ERROR (typo caught!)\n// handleChange('username', 123); // ‚ùå COMPILE ERROR (wrong type)\n\n\n// ========== USE CASE 3: API RESPONSE TYPES ==========\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  avatar?: string;\n  createdAt: Date;\n}\n\ninterface FetchUsersResponse {\n  status: 'success' | 'error';\n  data?: User[];\n  error?: string;\n}\n\nasync function fetchUsers(): Promise<FetchUsersResponse> {\n  try {\n    const response = await fetch('/api/users');\n    const data = await response.json();\n    \n    // TypeScript ensures response matches expected type\n    return {\n      status: 'success',\n      data: data.map((user: any) => ({\n        ...user,\n        createdAt: new Date(user.createdAt),\n      })),\n    };\n  } catch (error) {\n    return {\n      status: 'error',\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n// Using the response:\nasync function displayUsers() {\n  const response = await fetchUsers();\n  \n  if (response.status === 'success' && response.data) {\n    // ‚úÖ TypeScript knows:\n    // - response.data exists (it's required when status is 'success')\n    // - Each item in response.data is a User\n    // - User has id, name, email, createdAt\n    // - avatar is optional\n    response.data.forEach(user => {\n      console.log(`${user.name} (${user.email})`);\n    });\n  } else {\n    console.error(response.error);\n  }\n}\n\n\n// ========== USE CASE 4: EVENT HANDLER TYPES ==========\n\n// TypeScript knows the exact event types in React:\n\nfunction SearchInput() {\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    // ‚úÖ TypeScript knows:\n    // - e.target exists\n    // - e.target.value is a string\n    // - You can safely call string methods\n    const query = e.currentTarget.value.toLowerCase();\n  };\n  \n  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    // ‚úÖ Same event handler, different event type\n    // - e.preventDefault() exists\n    // - e.currentTarget is the form\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input onChange={handleInputChange} />\n    </form>\n  );\n}\n\n// Without TypeScript:\n// handleInputChange(\"not an event\"); // Would 'work' until runtime\n// e.target.notAProperty; // Would only fail at runtime\n\n// With TypeScript:\n// handleInputChange(\"not an event\"); // ‚ùå COMPILE ERROR\n// e.target.notAProperty; // ‚ùå COMPILE ERROR\n\n\n// ========== USE CASE 5: CONTEXT AND STATE MANAGEMENT ==========\n\ninterface ThemeContextType {\n  theme: 'light' | 'dark';\n  toggleTheme: () => void;\n}\n\nconst ThemeContext = React.createContext<ThemeContextType | undefined>(undefined);\n\nfunction ThemeProvider({ children }: { children: React.ReactNode }) {\n  const [theme, setTheme] = React.useState<'light' | 'dark'>('light');\n  \n  return (\n    <ThemeContext.Provider\n      value={{\n        theme,\n        toggleTheme: () => setTheme(t => t === 'light' ? 'dark' : 'light'),\n      }}\n    >\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\nfunction useTheme(): ThemeContextType {\n  const context = React.useContext(ThemeContext);\n  if (!context) {\n    throw new Error('useTheme must be used within ThemeProvider');\n  }\n  return context;\n}\n\n// Using it:\nfunction MyComponent() {\n  const { theme, toggleTheme } = useTheme();\n  // ‚úÖ TypeScript knows theme is 'light' | 'dark'\n  // ‚úÖ TypeScript knows toggleTheme is a function\n  // ‚úÖ Can't access non-existent properties\n}\n\n\n// ========== BENEFIT: REFACTORING LARGE CODEBASES ==========\n\n/**\n * Scenario: You're working with a large component library\n * Decision: Change \"label\" prop to \"text\" everywhere\n * \n * Without TypeScript:\n * - Find all usages manually\n * - Hope you didn't miss any\n * - Likely miss some\n * - QA finds them in production\n * \n * With TypeScript:\n * - Change interface: label ‚Üí text\n * - 47 COMPILE ERRORS shown immediately\n * - Fix all 47\n * - Zero surprises in production\n * \n * This scales:\n * - 10k components? Still catches everything\n * - 100k line codebase? Still instant feedback\n * - Large team? Everyone stays in sync\n */\n\n\n// ========== BENEFIT: PREVENTING PROP DRILLING MISTAKES ==========\n\ninterface AppProps {\n  userId: number;\n  theme: 'light' | 'dark';\n  onLogout: () => void;\n}\n\nfunction App(props: AppProps) {\n  return (\n    <PageLayout {...props}>\n      <Content {...props} />\n    </PageLayout>\n  );\n}\n\nfunction PageLayout(props: AppProps) {\n  return <div className={`bg-${props.theme}`}>{props.children}</div>;\n}\n\nfunction Content(props: AppProps) {\n  return <UserPanel userId={props.userId} onLogout={props.onLogout} />;\n}\n\nfunction UserPanel(props: Pick<AppProps, 'userId' | 'onLogout'>) {\n  return (\n    <div>\n      <p>User {props.userId}</p>\n      <button onClick={props.onLogout}>Logout</button>\n    </div>\n  );\n}\n\n// TypeScript prevents:\n// ‚ùå <UserPanel userId=\"123\" />; // Wrong type\n// ‚ùå <UserPanel userId={123} />; // Missing onLogout\n// ‚ùå <UserPanel userId={123} onLogout={null} />; // onLogout can't be null\n\n\n// ========== BENEFIT: AUTOCOMPLETE = DEVELOPER SPEED ==========\n\n/**\n * Without TypeScript:\n * Developer: \"What method gets array length?\"\n * Developer: \".len? .size? .count? .length?\"\n * Developer: Guesses, gets it wrong, wastes time\n * \n * With TypeScript:\n * Developer: Types \"array.\" \n * IDE: Shows autocomplete with all 50+ array methods\n * Developer: Finds .length, .map, .filter instantly\n * Developer: Unblocked in 0.5 seconds\n * \n * This compounds:\n * - 100 code decisions per day\n * - Each saves 5-10 seconds with TypeScript\n * - 8-16 minutes of focus time saved daily\n * - On a large team: 20 hours per week in productivity\n */\n\n\n// ========== REACT + TYPESCRIPT = PERFECT MATCH ==========\n\n/**\n * React + TypeScript is such a good combination that:\n * - Most production React apps use TypeScript\n * - Job listings often require TypeScript knowledge\n * - Modern React tooling (Next.js, etc.) default to TypeScript\n * - You WILL encounter this in your frontend career\n * \n * This course teaches TypeScript + React patterns because\n * that's the modern standard for professional frontend development.\n */\n\n\nexport {};\n